{
  "name": "useOnMountLayoutEffect",
  "type": "registry:hook",
  "description": "Hook that runs layout effect only on component mount",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:hook",
      "path": "hooks/useOnMountLayoutEffect.ts",
      "content": "\"use client\"\n\nimport * as React from \"react\"\n\n/**\n * A hook that runs a layout effect only once when the component mounts\n *\n * Similar to useOnMountEffect but uses useLayoutEffect instead of useEffect.\n * This fires synchronously after all DOM mutations but before the browser paints.\n * Use this when you need to make DOM measurements or mutations that must happen\n * before the browser paints to avoid visual inconsistencies.\n *\n * Features:\n * - Runs layout effect only on first mount\n * - Ignores dependency changes after first run\n * - Proper cleanup handling\n * - TypeScript support\n * - Synchronous execution before browser paint\n *\n * @param effect - The layout effect function to run on mount\n * @param dependencies - Optional dependencies array (effect runs when these change on first render only)\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const ref = useRef<HTMLDivElement>(null)\n *\n *   useOnMountLayoutEffect(() => {\n *     // Measure DOM element before paint\n *     if (ref.current) {\n *       const height = ref.current.offsetHeight\n *       console.log('Element height:', height)\n *     }\n *\n *     return () => {\n *       console.log('Cleanup on unmount')\n *     }\n *   })\n *\n *   return <div ref={ref}>Component content</div>\n * }\n * ```\n *\n * @example\n * ```tsx\n * // With dependencies (still only runs once)\n * function MyComponent({ theme }: { theme: string }) {\n *   useOnMountLayoutEffect(() => {\n *     // Apply theme synchronously before paint\n *     document.documentElement.setAttribute('data-theme', theme)\n *   }, [theme]) // theme is captured on mount, changes ignored\n *\n *   return <div>Themed content</div>\n * }\n * ```\n */\nexport function useOnMountLayoutEffect(\n  effect: React.EffectCallback,\n  dependencies?: React.DependencyList\n): void {\n  const hasRunRef = React.useRef(false)\n  const cleanupRef = React.useRef<void | (() => void) | undefined>(undefined)\n\n  React.useLayoutEffect(() => {\n    if (!hasRunRef.current) {\n      hasRunRef.current = true\n      cleanupRef.current = effect()\n    }\n\n    // Return cleanup function that calls the original cleanup\n    return () => {\n      if (cleanupRef.current) {\n        cleanupRef.current()\n        cleanupRef.current = undefined\n      }\n    }\n  }, dependencies) // eslint-disable-line react-hooks/exhaustive-deps\n}\n\n/**\n * A hook that runs a layout effect only once on the first render, ignoring all dependencies\n *\n * This is a stricter version of useOnMountLayoutEffect that completely ignores dependencies.\n * Uses useLayoutEffect for synchronous execution before browser paint.\n *\n * @param effect - The layout effect function to run on mount\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   useStrictMountLayoutEffect(() => {\n *     // This runs exactly once before paint, no matter what\n *     setupCriticalStyles()\n *   })\n *\n *   return <div>App content</div>\n * }\n * ```\n */\nexport function useStrictMountLayoutEffect(effect: React.EffectCallback): void {\n  const hasRunRef = React.useRef(false)\n  const cleanupRef = React.useRef<void | (() => void) | undefined>(undefined)\n\n  React.useLayoutEffect(() => {\n    if (!hasRunRef.current) {\n      hasRunRef.current = true\n      cleanupRef.current = effect()\n    }\n\n    return () => {\n      if (cleanupRef.current) {\n        cleanupRef.current()\n        cleanupRef.current = undefined\n      }\n    }\n  }, []) // No dependencies\n}\n\nexport default useOnMountLayoutEffect\n"
    }
  ]
}