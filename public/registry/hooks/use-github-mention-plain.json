{
  "name": "use-github-mention-plain",
  "type": "registry:hook",
  "namespace": "@ui-components/hooks",
  "description": "use-github-mention hook (plain, no cache)",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:hook",
      "path": "hooks/use-github-mention.ts",
      "content": "\"use client\"\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport { parseGithubUrl } from \"@/lib/github/parse-url\"\nimport type { GithubResource, ResourceKind } from \"@/lib/github/types\"\n\nexport type UseGithubMentionOptions = { useServer?: boolean }\nexport type UseGithubMentionResult = { kind: ResourceKind; data: GithubResource | null; isLoading: boolean; error: Error | null; refetch: () => void }\n\nfunction clientEndpointFor(url: string, useServer?: boolean): string | null {\n  const parsed = parseGithubUrl(url)\n  if (parsed.kind === \"unknown\") return null\n  if (useServer) { const params = new URLSearchParams({ url }); return `/api/github/resource?${params.toString()}` }\n  switch (parsed.kind) {\n    case \"pull\": return `https://api.github.com/repos/${parsed.owner}/${parsed.repo}/pulls/${parsed.number}`\n    case \"issue\": return `https://api.github.com/repos/${parsed.owner}/${parsed.repo}/issues/${parsed.number}`\n    case \"user\": return `https://api.github.com/users/${parsed.username}`\n    case \"repo\": return `https://api.github.com/repos/${parsed.owner}/${parsed.repo}`\n    default: return null\n  }\n}\n\nasync function fetchGithubResource(url: string, signal?: AbortSignal): Promise<GithubResource> {\n  const res = await fetch(url, { headers: { Accept: \"application/vnd.github+json\" }, cache: \"force-cache\", signal })\n  if (!res.ok) throw new Error(`GitHub request failed: ${res.status}`)\n  const json = (await res.json()) as unknown\n  return normalizeGithubResource(json)\n}\n\nfunction normalizeGithubResource(data: unknown): GithubResource {\n  if (typeof data !== \"object\" || data == null) throw new Error(\"Unsupported GitHub response shape\")\n  const obj = data as Record<string, unknown>\n  if (\"merged_at\" in obj || \"draft\" in obj) {\n    const user = obj.user as Record<string, unknown> | undefined\n    return { kind: \"pull\", id: obj.id as number, number: obj.number as number, state: (obj.state as string) === \"open\" ? \"open\" : \"closed\", merged: Boolean(obj.merged_at), draft: Boolean(obj.draft), title: obj.title as string, user: { login: user?.login as string, avatar_url: (user?.avatar_url as string) ?? null, html_url: user?.html_url as string }, created_at: obj.created_at as string, html_url: obj.html_url as string }\n  }\n  if (\"title\" in obj && \"comments\" in obj && \"user\" in obj && !(\"merged_at\" in obj)) {\n    const user = obj.user as Record<string, unknown> | undefined\n    return { kind: \"issue\", id: obj.id as number, number: obj.number as number, state: (obj.state as string) === \"open\" ? \"open\" : \"closed\", title: obj.title as string, user: { login: user?.login as string, avatar_url: (user?.avatar_url as string) ?? null, html_url: user?.html_url as string }, created_at: obj.created_at as string, html_url: obj.html_url as string, comments: obj.comments as number }\n  }\n  if (\"login\" in obj) {\n    return { kind: \"user\", id: obj.id as number, login: obj.login as string, name: (obj.name as string) ?? null, avatar_url: (obj.avatar_url as string) ?? null, html_url: obj.html_url as string }\n  }\n  if (\"full_name\" in obj) {\n    return { kind: \"repo\", id: obj.id as number, name: obj.name as string, full_name: obj.full_name as string, description: (obj.description as string) ?? null, html_url: obj.html_url as string }\n  }\n  throw new Error(\"Unsupported GitHub response shape\")\n}\n\nexport function useGithubMention(url: string, opts: UseGithubMentionOptions = {}): UseGithubMentionResult {\n  const [data, setData] = useState<GithubResource | null>(null)\n  const [error, setError] = useState<Error | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const abortRef = useRef<AbortController | null>(null)\n\n  const kind: ResourceKind = useMemo(() => parseGithubUrl(url).kind, [url])\n  const endpoint = useMemo(() => clientEndpointFor(url, opts.useServer), [url, opts.useServer])\n\n  const load = useCallback(async () => {\n    if (!endpoint) { setData(null); setError(new Error(\"Invalid GitHub URL\")); return }\n    abortRef.current?.abort()\n    const ac = new AbortController()\n    abortRef.current = ac\n    setIsLoading(true)\n    setError(null)\n    try {\n      const res = await fetchGithubResource(endpoint, ac.signal)\n      setData(res)\n    } catch (e: any) {\n      if (e?.name !== \"AbortError\") setError(e as Error)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [endpoint])\n\n  useEffect(() => { load(); return () => abortRef.current?.abort() }, [load])\n\n  return { kind, data, isLoading, error, refetch: load }\n}\n"
    }
  ]
}

