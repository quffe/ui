{
  "name": "useCountdown",
  "type": "registry:hook",
  "namespace": "@ui-components/hooks",
  "description": "Hook for countdown timers with auto-decrement",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:hook",
      "path": "hooks/useCountdown.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\n\n/**\n * Options for the countdown loop timer hook\n */\nexport interface UseCountdownLoopTimerOptions {\n  /** Interval between ticks in milliseconds */\n  intervalMs: number\n  /** Total duration per loop in milliseconds */\n  durationMs: number\n  /** Callback function called on each loop completion */\n  onTick: () => Promise<void> | void\n  /** Whether to start the timer immediately */\n  start?: boolean\n  /** Whether to auto-restart the timer after completion */\n  autoRestart?: boolean\n  /** Maximum number of loops (0 = infinite) */\n  maxLoops?: number\n}\n\n/**\n * Return type for the countdown loop timer hook\n */\nexport interface UseCountdownLoopTimerReturn {\n  /** Start the timer */\n  startTimer: () => void\n  /** Stop the timer */\n  stopTimer: () => void\n  /** Reset and restart the timer */\n  resetTimer: () => void\n  /** Pause the timer (preserves remaining time) */\n  pauseTimer: () => void\n  /** Resume a paused timer */\n  resumeTimer: () => void\n  /** Remaining time in milliseconds */\n  remainingMs: number\n  /** Remaining time in seconds (rounded up) */\n  remainingSeconds: number\n  /** Whether the timer is currently running */\n  isRunning: boolean\n  /** Whether the timer is paused */\n  isPaused: boolean\n  /** Number of completed loops */\n  loopCount: number\n  /** Progress as percentage (0-100) */\n  progress: number\n}\n\n/**\n * A hook for creating countdown timers with loop functionality\n *\n * Features:\n * - Customizable interval and duration\n * - Auto-restart capability\n * - Pause/resume functionality\n * - Loop counting with limits\n * - Progress tracking\n * - Async callback support\n * - Automatic cleanup\n *\n * @param options - Configuration options\n * @returns Object with timer controls and state\n *\n * @example\n * ```tsx\n * function CountdownTimer() {\n *   const {\n *     startTimer,\n *     stopTimer,\n *     remainingSeconds,\n *     isRunning,\n *     loopCount,\n *     progress\n *   } = useCountdownLoopTimer({\n *     intervalMs: 1000,\n *     durationMs: 30000, // 30 seconds\n *     onTick: async () => {\n *       console.log('Timer completed!')\n *       await fetchData() // Some async operation\n *     },\n *     autoRestart: true,\n *     maxLoops: 5\n *   })\n *\n *   return (\n *     <div>\n *       <div>Time remaining: {remainingSeconds}s</div>\n *       <div>Progress: {progress.toFixed(1)}%</div>\n *       <div>Loop: {loopCount}</div>\n *       <button onClick={isRunning ? stopTimer : startTimer}>\n *         {isRunning ? 'Stop' : 'Start'}\n *       </button>\n *     </div>\n *   )\n * }\n * ```\n */\nexport function useCountdownLoopTimer({\n  intervalMs,\n  durationMs,\n  onTick,\n  start = false,\n  autoRestart = false,\n  maxLoops = 0,\n}: UseCountdownLoopTimerOptions): UseCountdownLoopTimerReturn {\n  const [remainingMs, setRemainingMs] = React.useState(durationMs)\n  const [isRunning, setIsRunning] = React.useState(false)\n  const [isPaused, setIsPaused] = React.useState(false)\n  const [loopCount, setLoopCount] = React.useState(0)\n\n  const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n  const savedCallback = React.useRef(onTick)\n  const startTimeRef = React.useRef<number>(0)\n  const pausedTimeRef = React.useRef<number>(0)\n\n  // Keep callback reference fresh\n  React.useEffect(() => {\n    savedCallback.current = onTick\n  }, [onTick])\n\n  // Calculate progress percentage\n  const progress = ((durationMs - remainingMs) / durationMs) * 100\n\n  /**\n   * Clear the current interval\n   */\n  const clearCurrentInterval = React.useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current)\n      intervalRef.current = null\n    }\n  }, [])\n\n  /**\n   * Handle timer tick\n   */\n  const tick = React.useCallback(() => {\n    setRemainingMs(prev => {\n      const newRemaining = prev - intervalMs\n      return newRemaining <= 0 ? 0 : newRemaining\n    })\n  }, [intervalMs])\n\n  /**\n   * Handle loop completion\n   */\n  const handleLoopComplete = React.useCallback(async () => {\n    setIsRunning(false)\n    clearCurrentInterval()\n\n    try {\n      await savedCallback.current()\n    } catch (error) {\n      console.error(\"Error in onTick callback:\", error)\n    }\n\n    setLoopCount(prev => prev + 1)\n\n    // Check if we should restart\n    const newLoopCount = loopCount + 1\n    const shouldRestart = autoRestart && (maxLoops === 0 || newLoopCount < maxLoops)\n\n    if (shouldRestart) {\n      setRemainingMs(durationMs)\n      setIsRunning(true)\n      startTimeRef.current = Date.now()\n      intervalRef.current = setInterval(tick, intervalMs)\n    }\n  }, [autoRestart, maxLoops, loopCount, durationMs, tick, intervalMs, clearCurrentInterval])\n\n  /**\n   * Handle when remaining time reaches zero\n   */\n  React.useEffect(() => {\n    if (remainingMs <= 0 && isRunning) {\n      handleLoopComplete()\n    }\n  }, [remainingMs, isRunning, handleLoopComplete])\n\n  /**\n   * Start the timer\n   */\n  const startTimer = React.useCallback(() => {\n    if (isRunning || (maxLoops > 0 && loopCount >= maxLoops)) return\n\n    setIsRunning(true)\n    setIsPaused(false)\n    startTimeRef.current = Date.now()\n\n    if (intervalRef.current) clearInterval(intervalRef.current)\n    intervalRef.current = setInterval(tick, intervalMs)\n  }, [isRunning, maxLoops, loopCount, tick, intervalMs])\n\n  /**\n   * Stop the timer\n   */\n  const stopTimer = React.useCallback(() => {\n    setIsRunning(false)\n    setIsPaused(false)\n    clearCurrentInterval()\n  }, [clearCurrentInterval])\n\n  /**\n   * Pause the timer\n   */\n  const pauseTimer = React.useCallback(() => {\n    if (!isRunning || isPaused) return\n\n    setIsPaused(true)\n    setIsRunning(false)\n    pausedTimeRef.current = Date.now()\n    clearCurrentInterval()\n  }, [isRunning, isPaused, clearCurrentInterval])\n\n  /**\n   * Resume a paused timer\n   */\n  const resumeTimer = React.useCallback(() => {\n    if (!isPaused) return\n\n    setIsPaused(false)\n    setIsRunning(true)\n    startTimeRef.current = Date.now() - (pausedTimeRef.current - startTimeRef.current)\n\n    if (intervalRef.current) clearInterval(intervalRef.current)\n    intervalRef.current = setInterval(tick, intervalMs)\n  }, [isPaused, tick, intervalMs])\n\n  /**\n   * Reset and restart the timer\n   */\n  const resetTimer = React.useCallback(() => {\n    clearCurrentInterval()\n    setRemainingMs(durationMs)\n    setLoopCount(0)\n    setIsPaused(false)\n\n    if (start || isRunning) {\n      setIsRunning(true)\n      startTimeRef.current = Date.now()\n      intervalRef.current = setInterval(tick, intervalMs)\n    } else {\n      setIsRunning(false)\n    }\n  }, [durationMs, start, isRunning, tick, intervalMs, clearCurrentInterval])\n\n  // Auto-start on mount if requested\n  React.useEffect(() => {\n    if (start && !isRunning) {\n      startTimer()\n    }\n\n    // Cleanup on unmount\n    return () => {\n      clearCurrentInterval()\n    }\n  }, [start]) // Only run on mount\n\n  // Cleanup on unmount\n  React.useEffect(() => {\n    return () => {\n      clearCurrentInterval()\n    }\n  }, [clearCurrentInterval])\n\n  return {\n    startTimer,\n    stopTimer,\n    resetTimer,\n    pauseTimer,\n    resumeTimer,\n    remainingMs,\n    remainingSeconds: Math.ceil(remainingMs / 1000),\n    isRunning,\n    isPaused,\n    loopCount,\n    progress,\n  }\n}\n\n/**\n * Simple countdown hook for basic use cases\n *\n * @param initialTime - Initial countdown time in seconds\n * @param onComplete - Callback when countdown reaches zero\n * @returns Object with countdown state and controls\n *\n * @example\n * ```tsx\n * function SimpleCountdown() {\n *   const { seconds, start, stop, reset, isActive } = useCountdown(60, () => {\n *     alert('Time is up!')\n *   })\n *\n *   return (\n *     <div>\n *       <div>{seconds} seconds remaining</div>\n *       <button onClick={start}>Start</button>\n *       <button onClick={stop}>Stop</button>\n *       <button onClick={reset}>Reset</button>\n *     </div>\n *   )\n * }\n * ```\n */\nexport function useCountdown(initialTime: number, onComplete?: () => void) {\n  const { startTimer, stopTimer, resetTimer, remainingSeconds, isRunning } = useCountdownLoopTimer({\n    intervalMs: 1000,\n    durationMs: initialTime * 1000,\n    onTick: onComplete || (() => {}),\n    autoRestart: false,\n  })\n\n  return {\n    seconds: remainingSeconds,\n    start: startTimer,\n    stop: stopTimer,\n    reset: resetTimer,\n    isActive: isRunning,\n  }\n}\n"
    }
  ]
}